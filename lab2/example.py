"""
DNA序列比对算法使用示例和性能测试
演示两种不同实现的功能和性能特点
"""

from memory_efficient import MemoryEfficientAligner
from precomputed import PrecomputedAligner
from common import SequenceUtils
import time


def run_example():
    """运行示例测试"""
    
    # 测试序列（较短的示例）
    reference = "TGATTTAGAACGGACTTAGCAGACATTGAAACTCGAGGGGTATAGCAATAGATGCCCAAAAAGGTAAGCGCCATAAGCGTGGTTCTACGAGCCAGGTGCTCATGCCTAAGTTCTGCGCCTTCGCTGTCACTTGGAAATACTGTAATGGATCATGCCTAGGTTATGCGCCTTCGGGGTCACTTCAACATACTGTAATGGATCATGCCTAGGTTTTGCGTGTTCGCTGTCATTTCGAAATACTCCAATGGATGATGCCTAGGTTCTGTGCCTTCGCTGACGCATGGAAATACTTTAACGGATCATGCCCAGGCTCTGCGCCTTCGCTGAAACTTCGAAATACTCTAATGGATCATGCCTCGGTGCTCCACCTTCGCTTTCATTCCGAAATACTCTAATGGATCGCGTCCGTGTAACAACTTCGTACTGTTATATCGACCATCAGAATACCCATCCCTCGGGGAGGTAACCTATATTCACGTCGCAAGTTTCGATCTACAGTATGCTGACTGTTTGCCGCGATTTTAAGTCAAGAAGCGCGTCCACATGGTCGCGGTCGTCAACTTCAGTACGCTCATATGACACCAAAAGATCTACCTACAGCCCGTGCAGCTCGACTTTTGTGCTCTAGGGCACGACGGGTGGCGTTTGCTCCCGCGCATCTCGACTTTTAAGCTCTATGGCACAACGTGTGGCGTTTGCCCCCGCGCAGCTCGACTTTTGTGCTCTAGGGCACGGCGGGTGGCGTTTGCCCTCGCCCAGCTTGACTTTTGTGCTCTAGGGCACGACGGGTGGCGTTTGCCCCCGTGCAGCCCGACTTTTGTACTCTAGTGCACGACGGGTGGCGTTTGCCCCCGCACCGCTCGACTTTTGTGATCTAGGGCACTACGAGTAGCGTTGGCCCAGACAGATCAACGCACATGGATTCTCTAACAGGCCCCGCGCTTCTCATTGGCCCGTGAGACGGGTCTGAGAGGAAGACATTAGGTAGATACGGAAAGCTTTGGCGTAGTTCGTATCTTTCAGCGGTGAAGCGTCTTCGGTCCGGGCTGCGTTATGCCTGCGGGAGGAAGGCTCCACTAGATGGTTTACGAGACATAATGTCAGCTTCCTAAAGGTACGGCAGCGCCTGCGTATATCACAGGACGAATTGTCAGTTTGCTAGGGGTACGGGAGCGCTTGCGTATTACATAGGACGAATCGTCAGCTTCCTAAAGGGACGGTAGCGCTTGCGTGTTACATAGGACGAATTGTCAGCTTCGTAAAGGTACGGTAGTTCTTGCGTATTACATAGGATGCATTGTCCGCTTCCTAAAGGTACGCTGGCGCTTGCGTATCACATAGGACGGATAGCGCGATTGCTAAAGGTACGGGAGCGCTTGCGTCTTAGAGCGCACGAATCGGATATAAGCTGCGCCCGCGTCTGGCGAGCAAAAATCGTGGGAGCCAGCGAGGGAAAAACTGCTCGGGCGACTTAAACGGAATTACAAGACTCATTGCCATCGAGGACGTTAGACTAAAGAGCCCCTGCGTGCCTCCTTTGTATAGCTCGATGTAGTGGCCCGTGTATGTGGAACAGGAATGCTCGATCTAAGGTAGTAGTGGCTACAGCTCCGAGAGTTTGCGTACTGCGGTGCCAGGGATTTTGCCTGCGGGTACAGCCTCTGCGCACGCCGGTCTGTGATCAAGAACTAAACTAGAGA"[:1000]  # 截取前1000个字符用于测试
    
    query = "TGATTTAGAACGGACTTAGCAGACATTGAAACTCGAGGGGTATAGCAATAGATGCCCAAAAAGGTAAGCGCCATAAGCGTGTTTCTACGAGCCAGGTGCTCATGCCTAAGTTCTGCGCCTTCGCTGTCACTGGGAAATACTGTAATGGATCATCCGTAGGTTATGCGCCTTCGGGGTCACTTCAACATACTGTAACGGATCGTGCCTAGGTTTTGCGTATTCGCTGTCATTTCGAATTACACCAATGGATGATGCCTAGGTTCTGTGCCTCCGCTGACGCATCGAAATACTTTAACGGATCGCGTCCGAGTAACAACTTCGTACTGTTATATAGGCAATCAGAATACCCATGCCTCGGGGAGGTAACCTATATTCACGTCGCAAGTTTCGATCTACAGTACTGTAGGTATATCTTTTGGTGTCATATGAGGGTACTGAACTTGACGACCGCGACCATGTGGATGCGCTTCTTGACTTAAAATCGCGGCAAACAGTAAGCATCCGTGAAGCTCGACTTTTGTGCTCTAGGGCACGACGGGTGGCGTTTGCTCCCGCGCATCTCGAGTTGTAAGCTCTATGGCACAACGGGTGGCGTTTGCCGCCGAGCAGCTCGACTTTTGTGCTCTAGGGCACGGCGGGTGGCGTTTGCCCTCGCCCAGCTTGACTTTTGTGCTCTAGGGCACGACGGGTGGCCTTTGCCCCCGCGCAGCTGGACTTTTGTGCTCTAGGGCACGGCGGGTGGCGTTTGCCCTCCCCCAGCTTGACTACTGTGCTCTAGGGCACGACGGGTGGCGTTTGCCCCCGCGCAGCTCGACTTTTGTGCTCTATGGCACGGGGGGTGGCGTTTGCCCTCGCCCAGCTTGACTTTTGCGCTCTAGGGCACGACGGGTGGCGTTTGCCGGCAAACGCCACACGTCGTGCCCTAGAGCACAAACGTCAAGCTGGGCGAGGGCAACCGCCACCCGCCCTGCCCTAGAGCACAAAAGTCGAGCTGCGCGGGCCCGCGCAGCTCGACTTTTGTGCTCTAGGACACGGCGGGTGGCGTTTGCCCTCGCCCAGCTTGACTCTTGTGCTCTAGGGCACGACGGGTGGCGTTTGCCCCAGCGCAGCCCGACTTTTGTACTCTAGAGCACGACGGTTGGCATTTGCCCCCGCACCGCTCGACTTTTGTGATCTAGGGCCCTAGGAGTAGCGTTGGCCAGCTTTCCGTATCTACCTAATGTCTTCCTCTCAGACCCGTCTCACGGGCCAATGAGAAGCGCGGGGCCTATTAGAGAATCCATGTGCGTTGATCTGTCTGCAGACAGCTCAACGCACATGGATTCGCTAGCAGGCCCCGCGCTTCTCATTGGCCCGTGAGACGGGTCTGAGAGGAAGACATAAGGTAGATACGGCAAGCTCACGTCCGTGTAACAACGTCGTACTGTTATATCGACCATCAGAATCCCCATCCCGCGAGGAGGTAACCTATATTCAGGTCGCAAGTTTCGATCTACAGTATTGGCGTAGTTCGTATCTTTCAGCGGTGAAGCTTCTTCGGTCCGGGCTGCGTTATGCCTGCTGGAGGACGGCTCCACTAGATGGTTTACGAGACATAATGTCCGCTTCCTAAAGGTACACTGGCGCTTGAGTATCACATAGGACGGATAGCTCGATTCCTAAAGGGACGGGAGCGCTTGCGTCTTAGAGCGCATGAATCGTCAGCTTCCCAAAGGGACCGTAGCGCTTGCGTGTTATATAGGAAGAATGGTCAGCTTTGTAAAGGTACGGTAGTTCTTGCGTATTACAGAGGATGCATTGTCTACTACCTAAAGGTACGGCAGCGCCTGCGTATATCACAGGACGAATTGTCAGTTTGCTAGGGGTACGGGAGCGCTTGCATATTACATAGGACGAATCGGATATAAGCTGCGCCCGCGTCTGGCGATAAAAAATCGTGGTAGCCAGCGAGGGAAAAACTGCTCGGGCGACTTAAACGGAATTAAAAGACTCATTGCCGTGACAGACTTCCGTATAGCAACCTCTGGGATGTCGATGCGGTGTCCCCAGTCTGCGCTGAGCGGGGGCAGACAGACTTAGTTATAGTATGCATCTGTTTTAGCTAGACATCACGACCTAGTGGGGTTCATGTTGAGATTCTAGGGCGGTACGCAGCCGGTGGATTATTACTTCCCCAGAAATTCTGACTTCGTCACTGGATGGATTGTACTATCCGGTCAACCTTACAAGGTTTCAACAGGGACGAAGGGTAAACGTATGAAGCTTGGATGCCGTTACCGTAAAGGGCCCTATTGAAGTGTCGAGGACGTTAGACTAAAGAGCCCCTGCGTGCCTCCTTTGTATAGCTCGAGGTAGTGGCCCGGATATGTGGAACAGGAATGCTCGATCTAAGGTAGTAGTGGGTACCGCTCCGAGAGTTTGCGTACTGCGGTGCCCGGGATTTTGCCTGCGGGTACAGCCTCTGCGCACGCCGGTCTGTAATCAAGAACTAAACTAGAGA"[:1000]  # 截取前1000个字符用于测试
    
    print("=== DNA序列比对算法测试 ===\n")
    print(f"查询序列长度: {len(query)}")
    print(f"参考序列长度: {len(reference)}\n")
    
    # 测试内存高效算法
    print("1. 测试内存高效算法 (MemoryEfficientAligner)")
    print("-" * 50)
    
    start_time = time.time()
    memory_aligner = MemoryEfficientAligner()
    memory_results = memory_aligner.align(query, reference)
    memory_time = time.time() - start_time
    
    print(f"执行时间: {memory_time:.3f} 秒")
    print(f"找到片段数: {len(memory_results)}")
    print("匹配结果:")
    print(SequenceUtils.format_output(memory_results))
    
    memory_score = SequenceUtils.calculate_score(memory_results, query, reference)
    print(f"最终得分: {memory_score}\n")
    
    # 测试预计算算法
    print("2. 测试预计算算法 (PrecomputedAligner)")
    print("-" * 50)
    
    start_time = time.time()
    precomputed_aligner = PrecomputedAligner()
    precomputed_results = precomputed_aligner.align(query, reference)
    precomputed_time = time.time() - start_time
    
    print(f"执行时间: {precomputed_time:.3f} 秒")
    print(f"找到片段数: {len(precomputed_results)}")
    print("匹配结果:")
    print(SequenceUtils.format_output(precomputed_results))
    
    precomputed_score = SequenceUtils.calculate_score(precomputed_results, query, reference)
    print(f"最终得分: {precomputed_score}\n")
    
    # 性能比较
    print("3. 性能比较")
    print("-" * 50)
    print(f"内存高效算法 - 时间: {memory_time:.3f}s, 得分: {memory_score}")
    print(f"预计算算法   - 时间: {precomputed_time:.3f}s, 得分: {precomputed_score}")
    print(f"速度比: {memory_time/precomputed_time:.2f}x")
    
    # 详细片段信息
    print("\n4. 详细片段信息 (内存高效算法)")
    print("-" * 50)
    for i, seg in enumerate(memory_results):
        if seg.length >= 30:
            print(f"片段 {i+1}: {seg}")
            print(f"  坐标: ({seg.x0}, {seg.x1+1}, {seg.y0}, {seg.y1+1})")
            print(f"  长度: {seg.length}, 错误率: {seg.error_rate:.3f}")


def performance_test():
    """性能测试"""
    print("\n=== 性能测试 ===")
    
    # 生成不同长度的测试序列
    import random
    bases = ['A', 'T', 'C', 'G']
    
    lengths = [100, 200, 500, 1000]
    
    for length in lengths:
        print(f"\n测试序列长度: {length}")
        print("-" * 30)
        
        # 生成随机序列
        query = ''.join(random.choices(bases, k=length))
        reference = ''.join(random.choices(bases, k=length))
        
        # 测试内存高效算法
        start_time = time.time()
        memory_aligner = MemoryEfficientAligner()
        memory_results = memory_aligner.align(query, reference)
        memory_time = time.time() - start_time
        
        # 测试预计算算法
        start_time = time.time()
        precomputed_aligner = PrecomputedAligner()
        precomputed_results = precomputed_aligner.align(query, reference)
        precomputed_time = time.time() - start_time
        
        print(f"内存高效: {memory_time:.3f}s, 片段数: {len(memory_results)}")
        print(f"预计算:   {precomputed_time:.3f}s, 片段数: {len(precomputed_results)}")
        print(f"速度比:   {memory_time/precomputed_time:.2f}x")


if __name__ == "__main__":
    # 运行示例
    run_example()
    
    # 运行性能测试
    performance_test()
